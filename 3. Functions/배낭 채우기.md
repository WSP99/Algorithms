## 배낭 채우기 문제 (Knapsack Problem)
![image](https://user-images.githubusercontent.com/29484377/144378751-d1811285-95ea-4f4d-bcbc-980acd731693.png)
- 위 문제는 알고리즘에서 흔히 등장하는 배낭 채우기 문제 (Knapsack Problem)이다. 배낭 채우기 문제는 보석을 자를 수 있는지 가정하는 Fractional Knapsack 문제와 자를 수 없다고 가정하는 
0-1 Knapsack 문제가 있는데 보통 후자가 자주 사용된다. 
- 0-1 Knapsack 문제는 DP를 사용하여 풀이를 하는데 단순히 알고리즘 문제의 방법론을 사용하지 않고 문제풀이시 두가지 방법이 있다.  
  
**1. Butre Force**  
  - 모든 경우의 수를 모두 대입해보는 것으로 n개의 보석이 있다면 가능한 부분 집합의 수는 2^n개이다. 최악의 경우 시간복잡도가 O(2^n)이므로 매우 느린 방법이다.  

**2. Greedy**
  - 가격이 높은 보석 혹은 (가격/무게)가 가장 높은 보석을 먼저 골라서 넣는 방법이다.  
 ![image](https://user-images.githubusercontent.com/29484377/144379820-1f719810-4467-4629-88b6-f2733cf533be.png)  
  - 위 그림을 참조하여 가격이 제일 높은 보석을 먼저 고르는 방법을 쓴다면 오른쪽 아래의 빨간 보석을 먼저 고르고 다음 왼쪽에 있는 노란 보석을 고를텐데 그러면 10kg차고 가격은 16$가 된다.
  그런데 단순히 왼쪽 보석 3개만 합쳐도 17$가 나오며, 1/2/3/4kg 하나씩 넣어도 19$를 만들 수 있다.  
  ![image](https://user-images.githubusercontent.com/29484377/144381367-8473fda8-0053-4766-b392-37ac1df8b030.png)
  - 무게당 가격을 계산하여 보석을 넣으면 보석1, 보석3이 들어가며 가격의 합은 $19이다. 그런데 배낭의 무게 5kg이 남게되며 보석 2를 넣을 수 없으므로 5kg은 그냥 남는 공간이 된다.
   그러므로 보석2, 보석3을 넣으면 30kg이 꽉차고 가격의 합이 $20가 되어 도둑 입장에서는 무거울 수 있지만 배낭이 안터지는 한도 내에서 가격을 최대화할 수 있으므로 이것이 정답이다.
  - 이처럼 0-1 배낭 채우기 문제는 단순히 그리디 알고리즘으로 풀이할 수 없다.  
 **(단, Fractional Knapsack 문제는 Greedy로 풀 수 있다. 위 예시에서 보석2를 반으로 잘라 남은 5kg의 공간에 넣으면 그게 최적의 답이 된다.)**
 
 
 
**3. DP**
- 위 문제는 DP를 통해 풀이할 수 있는데 아래 두 가지를 만족하는 점화식으로 풀이할 수 있다.
  - 집합 A가 n번째 보석을 포함하지 않는다면, A는 n번째 보석을 뺀 나머 n-1개의 보석들 중에서 최적으로 고른 부분집합과 같다.
  - 집합 A가 n번째 보석을 포함한다면, A에 속한 보석들의 총 가격은 n-1개의 보석들 중에서 최적으로 고른 가격의 합에 보석 n의 가격을 더한 것과 같다.
  - 점화식은 다음과 같다.    
  ![image](https://user-images.githubusercontent.com/29484377/144394804-59927809-8a59-4e7f-8c58-587d63c86324.png)
  - P[i,w]란 i개의 보석이 있고 배낭 무게 한도가 w일 때 최적의 이익을 의미한다. 식을 문장으로 풀이한다면,  
   1. i번째 보석이 매낭 무게의 한도보다 무거우면 넣을 수 없으므로 i번째 보석을 뺀 i-1개의 보석들을 가지고 전 단계의 최적 값을 그대로 가져온다.
   2. 그렇지 않은 경우, i번째 보석을 위해 i번째 보석만큼 무게를 비웠을 때의 최적 값에 i번째 보석의 가격을 더한 값 이나 i-1개 보석들을 가지고 구한 전 단계의 최적 값 중 큰 것을 선택한다.
- 실제로 2차원 리스트를 채워보며 확인해본다면,   
    ![image](https://user-images.githubusercontent.com/29484377/144396308-54405b10-2001-4240-b304-dec9adda0626.png)  
  1. i가 0인 경우 넣을 보석이 없으므로 다 0이고, w가 0인 경우는 무게한도가 0이므로 넣을 보석이 없어 모두 0이다. 그러므로 첫번째 행과 첫번째 열은 모두 0으로 채우고 시작한다.  
  ![image](https://user-images.githubusercontent.com/29484377/144396584-d8b9a3f6-a74e-4347-bc88-7922e5143f06.png)  
  2. i = 1인 경우부터 살펴보면, (1,1)인 경우는 무게가 1인 보석이 없어 0이다. 그 다음 칸 (1,2)인 경우 1번 보석을 넣을 수 있어 3이 된다. 
  위의 식을 통해 보면 1번 보석의 가치 + V[0,0]의 값과 V[0,2]의 값을 비교하여 더 큰 쪽을 가져가는데 V[0,2]는 0이므로 전자를 선택하게 된다.
  현재 i = 1이므로 1번 보석을 넣고 더 이상 할게 없으므로 오른쪽의 남은 칸들도 모두 다 3이 된다.
 ![image](https://user-images.githubusercontent.com/29484377/144398469-08a4f7ad-7b55-48ab-8177-1ab7dd5341c3.png)
  3. i = 2인 경우 w = 2일때는 2번 보석을 바로 넣을 수 없어 바로 윗칸의 3을 가져온다. w = 3이 되면 2번 보석을 넣을 수 있게 되는데, 1번 보석을 넣었을 때 (바로 윗칸) 와 2번 보석을 넣을 만큼 공간을 확보하고 2번 보석을 넣었을 때 (즉 2번 보석 가치 + V[1,0])을 비교하여 더 가치가 큰 쪽을 선택한다. 그래서 4가 들어가게 된다.  
  ![image](https://user-images.githubusercontent.com/29484377/144399163-ff1db6fd-454f-47fe-bb1f-b3137aca7c14.png)  
  - (i,w)가 (2,5)인 경우 1번 보석과 2번 보석을 둘 다 넣을 수 있다. 3이 들어있던 (1,2)에서 최적값을 가져오고 1번 보석을 빼고 않고도 2번 보석을 넣을 수 있음을 의미한다. 즉 1번 보석의 최적 값 (3) + 2번 보석의 가격을 더해 7이 나옴을 알 수 있다.  
  ![image](https://user-images.githubusercontent.com/29484377/144399568-c00adfcd-42ce-4da2-99ad-b536445ae9f9.png)  
  4. 이런 식으로 나머지 값들도 계산해보면 마지막 칸에 결국 7이 들어가고, 이 마지막 칸이 최종 답이 되게 된다.

  

