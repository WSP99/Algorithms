## 배낭 채우기 문제 (Knapsack Problem)
![image](https://user-images.githubusercontent.com/29484377/144378751-d1811285-95ea-4f4d-bcbc-980acd731693.png)
- 위 문제는 알고리즘에서 흔히 등장하는 배낭 채우기 문제 (Knapsack Problem)이다. 배낭 채우기 문제는 보석을 자를 수 있는지 가정하는 Fractional Knapsack 문제와 자를 수 없다고 가정하는 
0-1 Knapsack 문제가 있는데 보통 후자가 자주 사용된다. 
- 0-1 Knapsack 문제는 DP를 사용하여 풀이를 하는데 단순히 알고리즘 문제의 방법론을 사용하지 않고 문제풀이시 두가지 방법이 있다.  
  
**1. Butre Force**  
  - 모든 경우의 수를 모두 대입해보는 것으로 n개의 보석이 있다면 가능한 부분 집합의 수는 2^n개이다. 최악의 경우 시간복잡도가 O(2^n)이므로 매우 느린 방법이다.  

**2. Greedy**
  - 가격이 높은 보석 혹은 (가격/무게)가 가장 높은 보석을 먼저 골라서 넣는 방법이다.  
 ![image](https://user-images.githubusercontent.com/29484377/144379820-1f719810-4467-4629-88b6-f2733cf533be.png)  
  - 위 그림을 참조하여 가격이 제일 높은 보석을 먼저 고르는 방법을 쓴다면 오른쪽 아래의 빨간 보석을 먼저 고르고 다음 왼쪽에 있는 노란 보석을 고를텐데 그러면 10kg차고 가격은 16$가 된다.
  그런데 단순히 왼쪽 보석 3개만 합쳐도 17$가 나오며, 1/2/3/4kg 하나씩 넣어도 19$를 만들 수 있다.  
  ![image](https://user-images.githubusercontent.com/29484377/144381367-8473fda8-0053-4766-b392-37ac1df8b030.png)
  - 무게당 가격을 계산하여 보석을 넣으면 보석1, 보석3이 들어가며 가격의 합은 $19이다. 그런데 배낭의 무게 5kg이 남게되며 보석 2를 넣을 수 없으므로 5kg은 그냥 남는 공간이 된다.
   그러므로 보석2, 보석3을 넣으면 30kg이 꽉차고 가격의 합이 $20가 되어 도둑 입장에서는 무거울 수 있지만 배낭이 안터지는 한도 내에서 가격을 최대화할 수 있으므로 이것이 정답이다.
  - 이처럼 0-1 배낭 채우기 문제는 단순히 그리디 알고리즘으로 풀이할 수 없다.  
 **(단, Fractional Knapsack 문제는 Greedy로 풀 수 있다. 위 예시에서 보석2를 반으로 잘라 남은 5kg의 공간에 넣으면 그게 최적의 답이 된다.)**
 
 
 
